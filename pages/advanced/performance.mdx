# Performance

As a library that serves the very fundamental functionality of all kinds of web apps, one of SWR’s top priorities is **performance**. 

Although most of the time the actual request won’t be triggered because of SWR’s built-in **caching** and **[deduplication](/advanced/performance#deduplication)**, 
the performance of the `useSWR` hook itself still matters. In a complex app, there could be hundreds of `useSWR` calls in a single page render.

SWR uses the following techniques to ensure there is:
- _no unnecessary requests_
- _no unnecessary re-renders_
- _no unnecessary code imported_

without any code changes from you.

## Deduplication

It’s very common to have SWR hooks reused in your app. For example you have an app to render the current user’s avatar 5 times:

```jsx
function useUser () {
  return useSWR('/api/user', fetcher)
}

function Avatar () {
  const { data, error } = useUser()

  if (error) return <Error />
  if (!data) return <Spinner />

  return <img src={data.avatar_url} />
}

function App () {
  return <>
    <Avatar />
    <Avatar />
    <Avatar />
    <Avatar />
    <Avatar />
  </>
}
```

Each `<Avatar>` component has a `useSWR` hook inside. Since they have the same SWR key and are rendered at the almost same time, **only 1 request will be made**.

You can reuse your data hooks (like `useUser` in the example above) as much as you want, without being worried about performance or duplicated requests.

There is also a [`dedupingInterval` option](/docs/options) for overriding the default deduplication interval.

## Deep Comparison

SWR **deep compares** data changes by default. If the `data` value isn’t changed, a re-render will not be triggered.

You can also customize the comparison function via the [`compare` option](/docs/options) if you want to change the behavior. 
For example some API responses return a server timestamp that you might want to exclude from the data diff.

## Dependency Collection

`useSWR` returns 3 **stateful** values: `data`, `error` and `isValidating`, each one can be updated independently.
For example, if we print those values within a full data-fetching lifecycle, it will be something like this:

```jsx
function App () {
  const { data, error, isValidating } = useSWR('/api', fetcher)
  console.log(data, error, isValidating)
  return null
}
```

In the worst case (the first request failed, then the retry was successful), you will see 5 lines of logs:

```js
// console.log(data, error, isValidating)
undefined undefined false // => hydration / initial render
undefined undefined true  // => start fetching
undefined Error false     // => end fetching, got an error
undefined Error true      // => start retrying
Data undefined false      // => end retrying, get the data
```

The state changes make totally sense. But that also means our component was **rendered 5 times**.

Now we change our component to only use `data`:

```jsx
function App () {
  const { data } = useSWR('/api', fetcher)
  console.log(data)
  return null
}
```

The magic happens — there are only **2 lines of logs** now:

```js
// console.log(data)
undefined // => hydration / initial render
Data      // => end retrying, get the data
```

The exact same process has happened internally, there was an error from the first request, then we got the data from the retry.
However, **SWR only updates the states that are used by the component**, which is only `data` now. 
That said, SWR has the ability to collect state dependencies automatically.

If you are not always using all these 3 states, you are already benefitting from this feature. 
It reduces ~60% unnecessary re-renders for [us](https://vercel.com).

## Tree Shaking

The SWR package is [tree-shakeable](https://webpack.js.org/guides/tree-shaking) and side-effect free. 
That means if you are only importing the core `useSWR` API, unused APIs like `useSWRInfinite` won't be bundled in your application.
